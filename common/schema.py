from datetime import datetime
from typing import Annotated

from pydantic import BaseModel, ConfigDict, EmailStr, Field, validate_email

from core.conf import settings

CUSTOM_VALIDATION_ERROR_MESSAGES = {
    "arguments_type": "Incorrect input for argument type",
    "assertion_error": "Assertion execution error",
    "bool_parsing": "Error parsing boolean value",
    "bool_type": "Incorrect input for boolean type",
    "bytes_too_long": "Input bytes length is too long",
    "bytes_too_short": "Input bytes length is too short",
    "bytes_type": "Incorrect input for bytes type",
    "callable_type": "Incorrect input for callable object type",
    "dataclass_exact_type": "Incorrect input for dataclass instance type",
    "dataclass_type": "Incorrect input for dataclass type",
    "date_from_datetime_inexact": "Non-zero date component input",
    "date_from_datetime_parsing": "Error parsing date input",
    "date_future": "Non-future date input",
    "date_parsing": "Date input validation error",
    "date_past": "Non-past date input",
    "date_type": "Incorrect input for date type",
    "datetime_future": "Non-future datetime input",
    "datetime_object_invalid": "Invalid datetime object input",
    "datetime_parsing": "Error parsing datetime input",
    "datetime_past": "Non-past datetime input",
    "datetime_type": "Incorrect input for datetime type",
    "decimal_max_digits": "Too many decimal digits input",
    "decimal_max_places": "Incorrect input for decimal places",
    "decimal_parsing": "Error parsing decimal input",
    "decimal_type": "Incorrect input for decimal type",
    "decimal_whole_digits": "Incorrect input for decimal digits",
    "dict_type": "Incorrect input for dictionary type",
    "enum": "Incorrect input for enum member, allowed values are {expected}",
    "extra_forbidden": "Extra fields input is forbidden",
    "finite_number": "Incorrect input for finite value",
    "float_parsing": "Error parsing float input",
    "float_type": "Incorrect input for float type",
    "frozen_field": "Incorrect input for frozen field",
    "frozen_instance": "Modifying frozen instance is not allowed",
    "frozen_set_type": "Incorrect input for frozen set type",
    "get_attribute_error": "Error getting attribute",
    "greater_than": "Input value is too large",
    "greater_than_equal": "Input value is too large or equal",
    "int_from_float": "Incorrect input for integer type",
    "int_parsing": "Error parsing integer input",
    "int_parsing_size": "Incorrect length for parsing integer input",
    "int_type": "Incorrect input for integer type",
    "invalid_key": "Invalid key value input",
    "is_instance_of": "Incorrect input for type instance",
    "is_subclass_of": "Incorrect input for type subclass",
    "iterable_type": "Incorrect input for iterable type",
    "iteration_error": "Incorrect input for iteration value",
    "json_invalid": "Invalid JSON string input",
    "json_type": "Incorrect input for JSON type",
    "less_than": "Input value is too small",
    "less_than_equal": "Input value is too small or equal",
    "list_type": "Incorrect input for list type",
    "literal_error": "Incorrect input for literal value",
    "mapping_type": "Incorrect input for mapping type",
    "missing": "Missing required field",
    "missing_argument": "Missing argument",
    "missing_keyword_only_argument": "Missing keyword-only argument",
    "missing_positional_only_argument": "Missing positional-only argument",
    "model_attributes_type": "Incorrect input for model attributes type",
    "model_type": "Incorrect input for model instance",
    "multiple_argument_values": "Too many argument values",
    "multiple_of": "Input value is not a multiple",
    "no_such_attribute": "Invalid attribute value assignment",
    "none_required": "Input value must be None",
    "recursion_loop": "Input circular assignment",
    "set_type": "Incorrect input for set type",
    "string_pattern_mismatch": "String constraint pattern does not match input",
    "string_sub_type": "Incorrect input for string sub-type (non-strict instance)",
    "string_too_long": "Input string is too long",
    "string_too_short": "Input string is too short",
    "string_type": "Incorrect input for string type",
    "string_unicode": "Input string is not Unicode",
    "time_delta_parsing": "Error parsing time delta input",
    "time_delta_type": "Incorrect input for time delta type",
    "time_parsing": "Error parsing time input",
    "time_type": "Incorrect input for time type",
    "timezone_aware": "Missing timezone input information",
    "timezone_naive": "Forbidden timezone input information",
    "too_long": "Input is too long",
    "too_short": "Input is too short",
    "tuple_type": "Incorrect input for tuple type",
    "unexpected_keyword_argument": "Unexpected keyword argument input",
    "unexpected_positional_argument": "Unexpected positional argument input",
    "union_tag_invalid": "Incorrect input for union type literal value",
    "union_tag_not_found": "Union type argument input not found",
    "url_parsing": "Error parsing URL input",
    "url_scheme": "Incorrect URL scheme input",
    "url_syntax_violation": "URL input syntax error",
    "url_too_long": "URL input is too long",
    "url_type": "Incorrect input for URL type",
    "uuid_parsing": "Error parsing UUID input",
    "uuid_type": "Incorrect input for UUID type",
    "uuid_version": "Incorrect input for UUID version type",
    "value_error": "Incorrect value input",
}

CUSTOM_USAGE_ERROR_MESSAGES = {
    "class-not-fully-defined": "Class attribute type is not fully defined",
    "custom-json-schema": "__modify_schema__ method is deprecated in V2",
    "decorator-missing-field": "Invalid field validator definition",
    "discriminator-no-field": "Not all discriminator fields are defined",
    "discriminator-alias-type": "Discriminator field is defined with non-string type",
    "discriminator-needs-literal": "Discriminator field needs to be defined with a literal",
    "discriminator-alias": "Inconsistent discriminator field alias definition",
    "discriminator-validator": "Discriminator field cannot have field validators",
    "model-field-overridden": "Overriding fields without type definition is not allowed",
    "model-field-missing-annotation": "Missing field type annotation",
    "config-both": "Duplicate configuration item definition",
    "removed-kwargs": "Calling deprecated keyword configuration parameters",
    "invalid-for-json-schema": "Invalid JSON type exists",
    "base-model-instantiated": "Instantiating base model is not allowed",
    "undefined-annotation": "Missing type definition",
    "schema-for-unknown-type": "Unknown type definition",
    "create-model-field-definitions": "Field definition error",
    "create-model-config-base": "Configuration item definition error",
    "validator-no-fields": "Field validator does not specify any fields",
    "validator-invalid-fields": "Field validator has invalid field definitions",
    "validator-instance-method": "Field validator must be a class method",
    "model-serializer-instance-method": "Serializer must be an instance method",
    "validator-v1-signature": "V1 field validator signature error (deprecated)",
    "validator-signature": "Field validator signature error",
    "field-serializer-signature": "Unrecognized field serializer signature",
    "model-serializer-signature": "Unrecognized model serializer signature",
    "multiple-field-serializers": "Duplicate field serializer definitions",
    "invalid_annotated_type": "Invalid annotated type definition",
    "type-adapter-config-unused": "Type adapter configuration item definition error",
    "root-model-extra": "Root model cannot define extra fields",
}
CustomPhoneNumber = Annotated[str, Field(pattern=r"^1[3-9]\d{9}$")]


class CustomEmailStr(EmailStr):
    """Custom email validation class"""

    @classmethod
    def _validate(cls, __input_value: str) -> str:
        return None if __input_value == "" else validate_email(__input_value)[1]


class SchemaBase(BaseModel):
    """Custom base model for Pydantic"""

    model_config = ConfigDict(
        use_enum_values=True,
        json_encoders={datetime: lambda x: x.strftime(settings.DATETIME_FORMAT)},
    )
